const arr = [1, 2, 3, 4, 5];

console.log(arr.reduce((n, m) => n + m));
// reduceは引数に着目してみる。第2引数mにはarr要素の値が順番に代入される。第１引数nには前回の関数の実行結果が入ってくる。
// そうして最終的にreduce()は最後に実行された値のみ返す。
console.log(arr.sort((n, m) => n > m ? -1 : 1));
// sortは並べ替えを行うメソッド。
// 注意として守らなくてはならないルールが3つある。
// 1.　第1引数が第2引数より優先度が高い（前に来る）場合は-1を返す。
// 2.　第1引数が第2引数より優先度が低い（後ろに来る）場合は1を返す。
// 3.　第1引数と第2引数の優先度が同じ（ソートの必要がない）場合は0を返す。【省略もできる】
// この場合はnがmより大きい場合、-1を返すルールが与えられてそれ以外の時は1を返すルールが与えられている。

// しかしJSのsortメソッドは結果が破壊的という性質があるためほかの処理と組み合わせるときは注意が必要！
const arr = [4, 8, 2, 6];
console.log(arr.sort((n, m) => n < m ? -1 : 1));  //[2, 4, 6, 8]
console.log(arr);  //[2, 4, 6, 8]

// JSの配列の破壊的メソッドと非破壊的メソッドを使うときの裏技にsliceメソッドを間にはさむ。
const lst = [5, 7, 1, 3];
console.log(lst.slice().sort((n, m) => n < m ? -1 : 1));
console.log(lst);